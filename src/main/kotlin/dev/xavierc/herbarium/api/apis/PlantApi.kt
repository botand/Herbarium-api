/**
 * Herbarium API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package dev.xavierc.herbarium.api.apis

import com.google.gson.Gson
import io.ktor.application.*
import io.ktor.auth.*
import io.ktor.http.*
import io.ktor.response.*
import dev.xavierc.herbarium.api.Paths
import io.ktor.locations.*
import io.ktor.routing.*
import dev.xavierc.herbarium.api.infrastructure.FirebasePrincipal
import dev.xavierc.herbarium.api.models.ErrorCode
import dev.xavierc.herbarium.api.models.PlantUpdateRequest
import dev.xavierc.herbarium.api.models.PutPlantRequest
import dev.xavierc.herbarium.api.models.UuidResponse
import dev.xavierc.herbarium.api.repositories.GreenhouseRepository
import dev.xavierc.herbarium.api.repositories.PlantRepository
import dev.xavierc.herbarium.api.utils.exceptions.NotFoundException
import io.ktor.request.*
import org.kodein.di.DI
import org.kodein.di.instance
import java.security.InvalidParameterException

@KtorExperimentalLocationsAPI
fun Route.PlantApi(di: DI) {
    val gson = Gson()
    val empty = mutableMapOf<String, Any?>()

    val greenhouseRepository by di.instance<GreenhouseRepository>()
    val plantRepository by di.instance<PlantRepository>()

//    authenticate("apiKey") {
    delete<Paths.deletePlant> { request ->
//            val principal = call.authentication.principal<ApiPrincipal>()!!

        // Check plant exist
        if (!plantRepository.exists(request.plantUuid)) {
            call.respond(HttpStatusCode.NotFound)
            return@delete
        }

        try {
            plantRepository.removePlant(request.plantUuid)
        } catch (e: InvalidParameterException) {
            call.respond(HttpStatusCode.Forbidden, ErrorCode(ErrorCode.Code.PLANT_ALREADY_REMOVED))
            return@delete
        }
        call.respond(HttpStatusCode.Accepted)
    }
//    }

    authenticate("firebase") {
        post<Paths.postActuatorState> {
            val userUuid = call.authentication.principal<FirebasePrincipal>()!!.userUuid

            call.respond(HttpStatusCode.NotImplemented)
        }
    }

    authenticate("firebase") {
        post<Paths.postUpdatePlant> { request ->
            val userUuid = call.authentication.principal<FirebasePrincipal>()!!.userUuid!!

            // Check if the plant exists and if the user can edit it.
            if (!plantRepository.exists(request.plantUuid) || !greenhouseRepository.isUserLinked(
                    plantRepository.getGreenhouseUuidForPlant(
                        request.plantUuid
                    ), userUuid
                )
            ) {
                call.respond(HttpStatusCode.NotFound)
                return@post
            }

            val plantUpdateRequest: PlantUpdateRequest = call.receive()
            try {
                if(plantUpdateRequest.movedPosition != null) {
                    try {
                        plantRepository.movePlant(request.plantUuid, plantUpdateRequest.movedPosition)
                    } catch (e: IllegalArgumentException) {
                        call.respond(HttpStatusCode.NotAcceptable)
                        return@post
                    } catch (e: NotFoundException) {
                        call.respond(HttpStatusCode.NotFound)
                        return@post
                    }
                    call.respond(HttpStatusCode.OK)
                    return@post
                }
                plantRepository.updatePlant(
                    request.plantUuid,
                    plantUpdateRequest.typeId,
                    plantUpdateRequest.overrideMoistureGoal,
                    plantUpdateRequest.overrideLightExposureMinDuration
                )
                call.respond(HttpStatusCode.OK)
            } catch (e: NotFoundException) {
                call.respond(HttpStatusCode.NotAcceptable, ErrorCode(ErrorCode.Code.DONT_EXISTS))
            }
        }
    }

//    authenticate("apiKey") {
    put<Paths.putPlant> { request ->
//            val principal = call.authentication.principal<ApiPrincipal>()!!

        val payload: PutPlantRequest = call.receive()

        // Validate the request
        if (payload.position >= 16 || payload.position < 0) {
            call.respond(HttpStatusCode.BadRequest, ErrorCode(ErrorCode.Code.PLANT_POSITION_INVALID))
            return@put
        }

        // Check the greenhouse exists
        if (!greenhouseRepository.exist(request.uuid)) {
            call.respond(HttpStatusCode.NotFound)
            return@put
        }

        // Check the plant position is free
        if (!plantRepository.positionFree(request.uuid, payload.position)) {
            call.respond(
                HttpStatusCode.Forbidden,
                ErrorCode(ErrorCode.Code.PLANT_POSITION_ALREADY_OCCUPIED)
            )
            return@put
        }

        // Add the plant
        val uuid = plantRepository.addPlant(request.uuid, payload.position, payload.plantedAt)
        call.respond(HttpStatusCode.Created, UuidResponse(uuid))
    }
//    }

    get<Paths.getPlantTypes> {
        call.respond(HttpStatusCode.OK, plantRepository.getPlantTypes(true))
    }
}
